\newcount\@lisp@gc@alloc@count
\def\@lisp@gc@alloc@count@max{10000}
\def\@lisp@gc@alloc@local{}
\def\@lisp@gc@alloc@local@eval{}

% gc initializer (called by lisp-on-tex.sty)
\def\@lisp@gc@init{%
  \@lisp@gc@alloc@count=0\relax
  \@tempcnta=0\relax
  \@whilenum\@tempcnta<\@lisp@gc@alloc@count@max\relax\do{%
    \expandafter\newif\csname if@lisp@gc@memory@\the\@tempcnta\endcsname
    \csname @lisp@gc@memory@\the\@tempcnta false\endcsname
    \advance\@tempcnta1}%
  \global\let\@lisp@gc@eval@orig\@eval
  \gdef\@eval#1#2#3#4{% hook evaluation
    \@lisp@gc@eval@orig#1{#2}{#3}#4%
    % memo the evaluation result
    \expandafter\expandafter\expandafter\def
    \expandafter\expandafter\expandafter\@lisp@gc@alloc@local@eval
    \expandafter\expandafter\expandafter{%
      \expandafter#4\@lisp@gc@alloc@local@eval}}%
  \global\let\@lisp@gc@\@@apply@create@env
}

% allocator
% The allocator define #1 to allocated the control sequence
\def\@lisp@gc@alloc#1{%
  \@lisp@gc@ms@try@alloc#1%
  \ifx#1\@empty
    \@lisp@gc@perform
    \@lisp@gc@ms@try@alloc#1%
    \ifx#1\@empty\def#1{\@tlabel@exception{{-1}{Memory is full}}}%
  \fi
}
\def\@lisp@gc@ms@try@alloc#1{%
  \csname if@lisp@gc@memory@\the\@lisp@gc@alloc@count\endcsname
     \let\@@next\@lisp@gc@ms@try@alloc@ % already allocated
  \else
     \let\@@next\@lisp@gc@ms@alloc@     % not allocated
  \fi\@@next#1}
\def\@lisp@gc@ms@alloc@#1{%
  % create a control sequence
  \expandafter\def\expandafter#1\expandafter{%
    \csname @lisp@gc@memory@\the\@lisp@gc@alloc@count\endcsname}%
  % toggle allocated flag on
  \csname @lisp@gc@memory@\the\@lisp@gc@alloc@count true\endcsname
  % memo allocated object on the call stack
  \toks0\expandafter{\@lisp@gc@alloc@local}%
  \edef\@lisp@gc@alloc@local{{\the\@lisp@gc@alloc@count}\the\toks0}%
  \advance\@lisp@gc@alloc@count1\relax}
\def\@lisp@gc@ms@try@alloc@#1{%
  \advance\@lisp@gc@alloc@count1\relax
  \if\@lisp@gc@alloc@count<\@lisp@gc@alloc@count@max
    \let\@@next\@lisp@gc@ms@try@alloc % try next
  \else
    \def#1{}% all memory is already allocated
    \let\@@next\@gobble
  \fi\@@next#1}

% GC main routine. The routine is called by the allocator.
% If you want to call GC manually, you can do it.
\def\@lisp@gc@perform{%
  % clear all allocated flag
  \@tempcnta=0\relax
  \@whilenum\@tempcnta<\@lisp@gc@alloc@count@max\relax\do{%
    \csname @lisp@gc@memory\the\@tempcnta false\endcsname
    \advance\@tempcnta1}
  % trace root set
  % 1. stack
  \expandafter\@lisp@gc@ms@mark@stack\@lisp@gc@alloc@local{}%
  % 2. global environment
  % reset
  \@lisp@gc@alloc@count0\relax}
\def\@lisp@gc@ms@mark@stack#1{%
  \def\@lisp@gc@ms@mark@stack@tmp{}%
  \if!#1!\else
    \csname if@lisp@gc@memory@#1\endcsname\else % not visited
      \csname @lisp@gc@memory@#1true\endcsname % toggle allocate flag on
      % deconstract
      \expandafter\expandafter\expandafter\@lisp@gc@ms@mark@stack@
        \csname @lisp@gc@memory@#1\endcsname
  \fi\fi
  \expandafter\@lisp@gc@ms@mark@stack\@lisp@gc@ms@mark@stack@tmp}
\def\@lisp@gc@ms@mark@object@#1#2{%
  \ifx#1\@tlabel@cons
    \let\@@next\@lisp@gc@ms@mark@object@cons
  \else\ifx#1\@tlabel@mutable
    \let\@@next\@lisp@gc@ms@mark@object@mutable
  \else
    \let\@@next\@gobble
  \fi\fi\@@next{#2}}
\def\@lisp@gc@ms@mark@object@cons#1{\@lisp@gc@ms@mark@object@cons@#1}
\def\@lisp@gc@ms@mark@object@cons@#1#2{%
  \@lisp@gc@ms@mark@object@deconstract#1%
  \@lisp@gc@ms@mark@object@deconstract#2}
\let\@lisp@gc@ms@mark@object@mutable\@lisp@gc@ms@mark@object@deconstract
\def\@lisp@gc@ms@mark@object@deconstract#1{%
  \expandafter\@lisp@gc@ms@mark@object@deconstract@\string#1\@@end}
\begingroup
\catcode`@=12
\catcode`|=0
\catcode`\\=12
|gdef|@lisp@gc@ms@mark@object@\@lisp@gc@memory#1|@@end{%
  \def
}
|endgroup

% pinning a object. 
% TODO: implement it
\def\@lisp@gc@pinning#1#2{}